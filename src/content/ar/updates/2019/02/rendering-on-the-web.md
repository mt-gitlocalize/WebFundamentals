project_path: "/web/_project.yaml"
book_path: "/web/updates/_book.yaml"

{# wf_updated_on: 2019-08-27 #} {# wf_published_on: 2019-02-06 #} {# wf_tags:
fundamentals, performance, app-shell #} {# wf_featured_image:
/web/updates/images/2019/02/rendering-on-the-web/icon.png #} {#
wf_featured_snippet: Where should we implement logic and rendering in our
applications? Should we use Server Side Rendering? What about Rehydration? Let's
find some answers! #} {# wf_blink_components: N/A #}

# التقديم على الويب {: .page-title }

{% include "web/_shared/contributors/developit.html" %} {% include
"web/_shared/contributors/addyosmani.html" %}

كمطورين ، نواجه غالبًا قرارات من شأنها التأثير على بنية تطبيقاتنا بالكامل. أحد
القرارات الأساسية التي يجب على مطوري الويب أن يتخذوها هي مكان تنفيذ المنطق
والعرض في تطبيقهم. قد يكون هذا الأمر صعبًا ، نظرًا لوجود عدد من الطرق المختلفة
لإنشاء موقع ويب.

يتم فهمنا لهذه المساحة من خلال عملنا في Chrome الذي يتحدث إلى مواقع كبيرة خلال
السنوات القليلة الماضية. بشكل عام ، نشجع المطورين على التفكير في تقديم الخوادم
أو التقديم الثابت على طريقة الإماهة الكاملة.

من أجل فهم أفضل للهندسة المعمارية التي نختار منها عندما نتخذ هذا القرار ، نحتاج
إلى فهم قوي لكل نهج ومصطلحات متسقة لاستخدامها عند التحدث عنها. تساعد الاختلافات
بين هذه الأساليب في توضيح المقايضات الخاصة بالعرض على الويب من خلال عدسة الأداء.

## المصطلحات {: #terminology }

**استدعاء**

- **SSR:** التقديم من جانب الخادم - تقديم تطبيق من جانب العميل أو تطبيق عالمي
إلى HTML على الخادم.
- **CSR:** التجسيد من جانب العميل - تقديم تطبيق في متصفح ، بشكل عام باستخدام
DOM.
- **الإماهة:** "تشغيل" طرق عرض JavaScript على العميل بحيث يعيدون استخدام شجرة
DOM وبيانات HTML المقدمة من الخادم.
- **Prerendering:** تشغيل تطبيق من جانب العميل في وقت البناء لالتقاط حالته
الأولية كـ HTML ثابت.

**أداء**

- **TTFB:** الوقت اللازم **للبايت** الأول - يُنظر إليه على أنه الوقت بين النقر
على الرابط والجزء الأول من المحتوى الوارد.
- **FP:** First Paint - أول مرة يصبح فيها أي بكسل مرئية للمستخدم.
- **FCP:** الرسام الأول المفيد - الوقت الذي يصبح فيه المحتوى المطلوب (نص المقالة
، إلخ) مرئيًا.
- **TTI:** Time To Interactive - الوقت الذي تصبح فيه الصفحة تفاعلية (الأحداث
متصلة ، إلخ).

## تقديم الخادم {: #server-rendering }

*يقوم تقديم الخادم بإنشاء HTML الكامل لصفحة على الخادم استجابةً للملاحة. يؤدي
ذلك إلى تجنب رحلات الذهاب والإياب الإضافية لجلب البيانات وتثبيتها على العميل ،
نظرًا لأنه يتم التعامل معها قبل استجابة المستعرض.*

يؤدي تقديم الخادم عمومًا إلى [الرسام
الأول](https://developers.google.com/web/fundamentals/performance/user-centric-performance-metrics#first_paint_and_first_contentful_paint)
السريع (FP) [والطلاء الأول
للمحتوى](https://developers.google.com/web/fundamentals/performance/user-centric-performance-metrics#first_paint_and_first_contentful_paint)
(FCP). يتيح تشغيل منطق الصفحة وعرضه على الخادم تجنب إرسال الكثير من JavaScript
إلى العميل ، مما يساعد على تحقيق [وقت
تفاعلي](https://developers.google.com/web/tools/lighthouse/audits/time-to-interactive)
سريع (TTI). هذا أمر منطقي ، حيث أنه مع تقديم الخادم ، فأنت فقط ترسل النص
والروابط إلى متصفح المستخدم. يمكن لهذا النهج أن يعمل بشكل جيد مع مجموعة كبيرة من
ظروف الجهاز والشبكة ، ويفتح تحسينات متصفح مثيرة للاهتمام مثل تحليل تدفق الوثائق.

<img src="../../images/2019/02/rendering-on-the-web/server-rendering-tti.png"
alt="Diagram showing server rendering and JS execution affecting FCP and TTI"
width="350">

من خلال تقديم الخوادم ، من غير المرجح أن يتم ترك المستخدمين في انتظار جافا
سكريبت المرتبط بوحدة المعالجة المركزية للمعالجة قبل أن يتمكنوا من استخدام موقعك.
حتى عندما يتعذر تجنب [JS لجهة
خارجية](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/loading-third-party-javascript/)
، فإن استخدام تجسيد الخادم لتقليل [تكاليف
JS](https://medium.com/@addyosmani/the-cost-of-javascript-in-2018-7d8950fbb5d4)
الخاصة بالطرف الأول قد يمنحك المزيد من "
[الميزانية](https://medium.com/@addyosmani/start-performance-budgeting-dabde04cf6a3)
" للباقي. ومع ذلك ، هناك عيب أساسي واحد لهذا النهج: إنشاء صفحات على الخادم
يستغرق وقتًا ، مما قد يؤدي غالبًا إلى
[وقت](https://en.wikipedia.org/wiki/Time_to_first_byte) أبطأ للبايت
[الأول](https://en.wikipedia.org/wiki/Time_to_first_byte) (TTFB).

ما إذا كان تقديم الخادم كافيًا لتطبيقك يعتمد إلى حد كبير على نوع الخبرة التي
تنشئها. هناك جدل طويل حول التطبيقات الصحيحة لتقديم الخادم مقابل العرض من جانب
العميل ، ولكن من المهم أن تتذكر أنه يمكنك اختيار استخدام عرض الخادم لبعض الصفحات
وليس الصفحات الأخرى. اعتمدت بعض المواقع تقنيات تقديم هجينة بنجاح. يعرض خادم
[Netflix](https://medium.com/dev-channel/a-netflix-web-performance-case-study-c0bcde26a9d9)
الصفحات المقصودة الثابتة نسبيًا ، في حين
[يسبق](https://dev.to/addyosmani/speed-up-next-page-navigations-with-prefetching-4285)
إعداد JS للصفحات شديدة التفاعل ، مما يتيح لهذه الصفحات الأثقل التي يقدمها العميل
فرصة أفضل للتحميل بسرعة.

العديد من الأطر الحديثة والمكتبات والمعماريات تجعل من الممكن تقديم نفس التطبيق
على كل من العميل والخادم. هذه التقنيات يمكن أن تستخدم لخادم التقديم، ولكن من
المهم أن نلاحظ أن أبنية حيث يحدث التقديم سواء على الخادم ***وعلى*** العميل من
الدرجة الخاصة من حل مع خصائص الأداء مختلفة جدا والمفاضلات. يمكن للمستخدمين الذين
يستخدمون [React](https://reactjs.org/docs/react-dom-server.html) استخدام
[renderToString ()](https://reactjs.org/docs/react-dom-server.html) أو الحلول
المبنية فوقه مثل [Next.js](https://nextjs.org) لتقديم الخادم. يمكن لمستخدمي Vue
إلقاء نظرة على [دليل تقديم خادم](https://ssr.vuejs.org) Vue أو
[Nuxt](https://nuxtjs.org) . الزاوي لديه
[العالمي](https://angular.io/guide/universal) . تستخدم معظم الحلول الشائعة شكلاً
من أشكال الماء ، لذلك كن على دراية بالنهج المستخدم قبل اختيار الأداة.

## تقديم ثابت {: #static-rendering }

يحدث [التجسيد الثابت](https://frontarm.com/articles/static-vs-server-rendering/)
في وقت الإنشاء ويقدم الطلاء الأول السريع والطلاء الأول والمحتوى التفاعلي - على
افتراض أن حجم JS من جانب العميل محدود. بخلاف تقديم الخادم ، فإنه يدير أيضًا
تحقيق وقت سريع للبايت الأول ، حيث لا يلزم إنشاء HTML للصفحة أثناء الطيران. بشكل
عام ، يعني العرض الثابت إنتاج ملف HTML منفصل لكل عنوان URL في وقت مبكر. مع إنشاء
استجابات HTML مقدمًا ، يمكن نشر التجسيدات الثابتة على عدة شبكات CDN للاستفادة من
التخزين المؤقت على الحافة.

<img src="../../images/2019/02/rendering-on-the-web/static-rendering-tti.png"
alt="Diagram showing static rendering and optional JS execution affecting FCP
and TTI" width="280">

حلول التقديم الثابت تأتي في جميع الأشكال والأحجام. تم تصميم أدوات مثل
[Gatsby](https://www.gatsbyjs.org) لجعل المطورين يشعرون أن تطبيقهم يتم تقديمه
ديناميكيًا بدلاً من إنشاؤه كخطوة بناء. يحتضن آخرون مثل
[Jekyl](https://jekyllrb.com) و [Metalsmith](https://metalsmith.io) طبيعتهم
الساكنة ، مما يوفر مقاربة تعتمد على القالب.

أحد الجوانب السلبية للتجسيد الثابت هو أنه يجب إنشاء ملفات HTML الفردية لكل عنوان
URL ممكن. قد يكون هذا أمرًا صعبًا أو حتى غير ممكن عندما لا يمكنك التنبؤ بما
ستكون عليه عناوين URL هذه في وقت مبكر أو للمواقع التي تحتوي على عدد كبير من
الصفحات الفريدة.

قد يكون [مستخدمو React على](https://nextjs.org/learn/excel/static-html-export/)
دراية [بالتصدير الثابت لـ](https://nextjs.org/learn/excel/static-html-export/)
[Gatsby](https://www.gatsbyjs.org) أو
[Next.js](https://nextjs.org/learn/excel/static-html-export/) أو
[Navi](https://frontarm.com/navi/) - وكلها تجعلها ملائمة للمؤلف باستخدام
المكونات. ومع ذلك ، من المهم فهم الفرق بين العرض الثابت والعرض المسبق: الصفحات
الثابتة المقدمة تفاعلية دون الحاجة إلى تنفيذ الكثير من JS من جانب العميل ، في
حين أن العرض المسبق يحسن الطلاء الأول أو الطلاء الأول للمحتوى لتطبيق الصفحة
الواحدة الذي يجب تشغيله العميل من أجل الصفحات لتكون تفاعلية حقا.

إذا كنت غير متأكد ما إذا كان الحل المحدد هو العرض الثابت أو العرض المسبق ، فجرّب
هذا الاختبار: قم بتعطيل JavaScript وتحميل صفحات الويب التي تم إنشاؤها. بالنسبة
للصفحات المقدمة بشكل ثابت ، ستظل معظم الوظائف موجودة بدون تمكين JavaScript.
بالنسبة للصفحات المقدمة مسبقًا ، قد لا تزال هناك بعض الوظائف الأساسية مثل
الروابط ، ولكن معظم الصفحة ستكون خاملة.

هناك اختبار آخر مفيد وهو إبطاء الشبكة باستخدام Chrome DevTools ، ومراقبة مقدار
جافا سكريبت الذي تم تنزيله قبل أن تصبح الصفحة تفاعلية. يتطلب Prerendering عمومًا
المزيد من جافا سكريبت للحصول على تفاعل ، ويميل JavaScript إلى أن يكون أكثر
تعقيدًا من نهج [التحسين
التدريجي](https://developer.mozilla.org/en-US/docs/Glossary/Progressive_Enhancement)
المستخدم في العرض الثابت.

## Server Rendering vs Static Rendering {: #server-vs-static }

لا يمثل تقديم الخادم رمزًا فضيًا - حيث يمكن أن تأتي طبيعته الديناميكية مع تكاليف
[حسابية
كبيرة](https://medium.com/airbnb-engineering/operationalizing-node-js-for-server-side-rendering-c5ba718acfc9)
. لا تتدفق كثيرًا من حلول تقديم الخوادم في وقت مبكر ، ويمكن أن تؤخر TTFB أو
تضاعف البيانات التي يتم إرسالها (مثل الحالة المضمنة التي تستخدمها JS على
العميل). في React ، يمكن أن يكون renderToString () بطيئًا لأنه متزامن ومترابط
واحد. يمكن أن يتضمن الحصول على "تقديم" الخادم "الصحيح" إيجاد أو إنشاء حل
[للتخزين المؤقت
للمكونات](https://medium.com/@reactcomponentcaching/speedier-server-side-rendering-in-react-16-with-component-caching-e8aa677929b1)
، وإدارة استهلاك الذاكرة ، وتطبيق تقنيات
[المذكرات](https://speakerdeck.com/maxnajim/hastening-react-ssr-with-component-memoization-and-templatization)
، والعديد من الاهتمامات الأخرى. عادة ما تقوم بمعالجة / إعادة بناء نفس التطبيق
عدة مرات - مرة واحدة على العميل ومرة واحدة في الخادم. لمجرد أن تقديم الخادم يمكن
أن يجعل ظهور شيء ما عاجلاً لا يعني فجأة أن لديك عمل أقل للقيام به.

يُنتج تقديم الخادم HTML عند الطلب لكل عنوان URL ولكن يمكن أن يكون أبطأ من مجرد
تقديم محتوى ثابت. إذا كنت تستطيع وضع العمل الإضافي في العمل ، فيمكن أن يؤدي
تقديم الخادم + [التخزين المؤقت لـ HTML
إلى](https://freecontent.manning.com/caching-in-react/) تقليل وقت تقديم الخادم
بشكل كبير. يتمثل الجانب العلوي في تقديم الخادم في القدرة على سحب المزيد من
البيانات "المباشرة" والاستجابة لمجموعة كاملة من الطلبات أكثر مما هو ممكن مع
العرض الثابت. تعد الصفحات التي تتطلب التخصيص مثالًا ملموسًا على نوع الطلب الذي
لن يعمل بشكل جيد مع العرض الثابت.

يمكن أن يعرض تقديم الخادم أيضًا قرارات مثيرة للاهتمام عند إنشاء
[PWA](https://developers.google.com/web/progressive-web-apps/) . هل من الأفضل
استخدام التخزين المؤقت [للعامل في
خدمة](https://developers.google.com/web/fundamentals/primers/service-workers/)
صفحة كاملة ، أم مجرد تقديم أجزاء فردية من المحتوى؟

## التقديم من جانب العميل (CSR) {: #csr }

*التقديم من جانب العميل (CSR) يعني تقديم الصفحات مباشرة في المستعرض باستخدام
JavaScript. يتم التعامل مع كل المنطق ، وجلب البيانات ، templating والتوجيه على
العميل بدلا من الخادم.*

قد يكون الحصول على العرض من جانب العميل أمرًا صعبًا للجوال. يمكن أن يقترب من
أداء تقديم الخادم الخالص إذا كان الحد الأدنى من العمل ، والحفاظ على [ميزانية
جافا سكريبت
ضيقة](https://mobile.twitter.com/HenrikJoreteg/status/1039744716210950144)
وتقديم قيمة في عدد قليل من
[RTTs](https://en.wikipedia.org/wiki/Round-trip_delay_time) ممكن. يمكن تسليم
البرامج النصية الهامة والبيانات في وقت أقرب باستخدام [HTTP / 2 Server
Push](https://www.smashingmagazine.com/2017/04/guide-http2-server-push/) أو
`<link rel=preload>` ، مما يجعل المحلل يعمل من أجلك. تستحق أنماط مثل
[PRPL](https://developers.google.com/web/fundamentals/performance/prpl-pattern/)
تقييمها من أجل ضمان أن تكون عمليات التنقل الأولية واللاحقة فورية.

<img src="../../images/2019/02/rendering-on-the-web/client-rendering-tti.png"
alt="Diagram showing client-side rendering affecting FCP and TTI" width="500">

الجانب السلبي الأساسي لتقديم جانب العميل هو أن كمية جافا سكريبت المطلوبة تميل
إلى النمو مع نمو التطبيق. يصبح هذا أمرًا صعبًا بشكل خاص مع إضافة مكتبات
JavaScript جديدة ، وملفات polyfills ورمز جهة خارجية ، والتي تتنافس على قوة
المعالجة ويجب معالجتها غالبًا قبل عرض محتوى الصفحة. يجب أن تأخذ التجارب التي تم
إنشاؤها باستخدام CSR والتي تعتمد على حزم JavaScript كبيرة في الاعتبار [تقسيم
التعليمات البرمجية بشكل
كبير](https://developers.google.com/web/fundamentals/performance/optimizing-javascript/code-splitting/)
، وتأكد من تحميل جافا سكريبت - "لا تخدم إلا ما تحتاج إليه ، عندما تحتاج إليه".
بالنسبة للتجارب ذات التفاعل القليل أو عدم التفاعل ، يمكن أن يمثل تقديم الخادم
حلاً أكثر قابلية للتطوير لهذه المشكلات.

بالنسبة إلى الأشخاص الذين يقومون بإنشاء تطبيق صفحة واحدة ، فإن تحديد الأجزاء
الأساسية لواجهة المستخدم المشتركة بين معظم الصفحات يعني أنه يمكنك تطبيق تقنية
[التخزين المؤقت لأداة
التطبيق](https://developers.google.com/web/updates/2015/11/app-shell) . إلى جانب
العاملين في الخدمة ، يمكن أن يؤدي هذا إلى تحسين الأداء المتوقع بشكل كبير في
الزيارات المتكررة.

## الجمع بين تقديم الخادم و CSR عبر الإماهة {: #rehydration }

غالباً ما يشار إليها باسم "التقديم العالمي" أو "SSR" ، يحاول هذا النهج التخفيف
من المفاضلة بين التقديم من جانب العميل وتقديم الخادم عن طريق القيام بكليهما. تتم
معالجة طلبات التنقل مثل التحميل الكامل للصفحة أو إعادة التحميل بواسطة خادم يعرض
التطبيق على HTML ، ثم يتم تضمين JavaScript والبيانات المستخدمة في العرض في
المستند الناتج. عند تنفيذه بعناية ، يحقق ذلك "رسم المحتوى الأول السريع" تمامًا
مثل "تقديم الخادم" ، ثم "يلتقط" من خلال تقديمه مرة أخرى على العميل باستخدام
تقنية تسمى [(إعادة)
الترطيب](https://docs.electrode.io/guides/general/server-side-data-hydration) .
هذا حل جديد ، لكن يمكن أن يكون له بعض عيوب الأداء.

الجانب السلبي الأساسي من SSR مع الإماهة هو أنه يمكن أن يكون لها تأثير سلبي كبير
على Time To Interactive ، حتى لو كان يحسن First Paint. غالبًا ما تبدو صفحات SSR
التي تم تحميلها وتفاعلية مضللة ، لكن لا يمكنها في الواقع الاستجابة للمدخلات حتى
يتم تنفيذ JS من جانب العميل وإرفاق معالجات الأحداث. قد يستغرق هذا ثواني أو حتى
دقائق على الهاتف المحمول.

ربما تكون قد واجهت هذا بنفسك - لفترة من الوقت بعد أن بدا وكأن الصفحة قد تم
تحميلها ، فإن النقر أو النقر لا يفعل شيئًا. هذا سرعان ما أصبح محبطًا ... *"لماذا
لا يحدث شيء؟ لماذا لا يمكنني التمرير؟*

### مشكلة الإماهة: تطبيق واحد لسعر اثنين {: #rehydration-issues }

يمكن أن تكون مشاكل الإماهة أسوأ من التفاعل المتأخر بسبب JS. لكي تتمكن JavaScript
من جانب العميل من "الانتقاء" بدقة حيث توقف الخادم دون الحاجة إلى إعادة طلب جميع
البيانات التي استخدمها الخادم لتقديم HTML ، تقوم حلول SSR الحالية بشكل عام
بتسلسل الاستجابة من واجهة المستخدم تبعيات البيانات في المستند كعلامات برنامج
نصي. يحتوي مستند HTML الناتج على مستوى عالي من التكرار:

<img src="../../images/2019/02/rendering-on-the-web/html.png" alt="HTML document
containing serialized UI, inlined data and a bundle.js script">

كما ترون ، يعرض الخادم وصفًا لواجهة المستخدم الخاصة بالتطبيق استجابةً لطلب
الملاحة ، ولكنه يقوم أيضًا بإرجاع البيانات المصدر المستخدمة لإنشاء واجهة
المستخدم هذه ، ونسخة كاملة من تنفيذ واجهة المستخدم والتي يتم تشغيلها بعد ذلك على
العميل . فقط بعد انتهاء bundle.js من التحميل والتنفيذ ، تصبح واجهة المستخدم هذه
تفاعلية.

تشير مقاييس الأداء التي تم جمعها من مواقع الويب الحقيقية باستخدام نظام الإماهة
SSR إلى ضرورة عدم تشجيع استخدامه بشدة. في النهاية ، يكمن السبب في تجربة
المستخدم: من السهل جدًا أن ينتهي الأمر بترك المستخدمين في "وادي غريب".

<img src="../../images/2019/02/rendering-on-the-web/rehydration-tti.png"
alt="Diagram showing client rendering negatively affecting TTI" width="600">

هناك أمل ل SSR مع الجفاف ، على الرغم من. في المدى القصير ، لا يؤدي استخدام SSR
إلا للمحتوى القابل للتخزين المؤقت بدرجة كبيرة إلى تقليل تأخير TTFB ، مما يؤدي
إلى نتائج مماثلة للتقديم المسبق. قد تكون إعادة الترطيب [بشكل
تدريجي](https://www.emberjs.com/blog/2017/10/10/glimmer-progress-report.html) أو
تدريجي أو جزئي هي المفتاح لجعل هذه التقنية أكثر قابلية للتطبيق في المستقبل.

## دفق تجسيد الخادم والتقدم التدريجي {: #progressive-rehydration }

شهد تقديم الخوادم عددًا من التطورات على مدار السنوات القليلة الماضية.

يسمح لك [عرض خادم
البث](https://zeit.co/blog/streaming-server-rendering-at-spectrum) بإرسال HTML
في مجموعات يمكن للمتصفح عرضها تدريجياً عند استلامها. يمكن أن يوفر هذا رسمًا
سريعًا للطلاء الأول والطلاء الأول للمحتوى مع وصول العلامات للمستخدمين بشكل أسرع.
في React ، تدفقات كونها غير متزامنة في [renderToNodeStream
()](https://reactjs.org/docs/react-dom-server.html#rendertonodestream) - مقارنة
مع renderToString متزامن - يعني معالجة الضغط الخلفي بشكل جيد.

الإماهة التدريجية تستحق الاهتمام أيضًا ، وقد تم
[استكشاف](https://github.com/facebook/react/pull/14717) شيء تفاعلي. باستخدام هذا
النهج ، يتم "تشغيل" الأجزاء الفردية للتطبيق المقدم من الخادم مع مرور الوقت ،
بدلاً من النهج الشائع الحالي لتهيئة التطبيق بأكمله مرة واحدة. يمكن أن يساعد ذلك
في تقليل مقدار JavaScript المطلوب لجعل الصفحات تفاعلية ، حيث يمكن تأجيل ترقية
الأجزاء ذات الأولوية المنخفضة للصفحة من جانب العميل لمنع حظر سلسلة الرسائل
الرئيسية. يمكن أن يساعد أيضًا في تجنب أحد عطل SSR Rehydration الأكثر شيوعًا ،
حيث يتم إتلاف شجرة DOM المقدمة من الخادم ومن ثم إعادة بنائها فورًا - في أغلب
الأحيان لأن التجسيد الأولي المتزامن من جانب العميل يتطلب بيانات لم تكن جاهزة
تمامًا ، وربما في انتظار وعد القرار.

### الإماهة الجزئية {: #partial-rehydration }

ثبت أن الإماهة الجزئية صعبة التنفيذ. هذا النهج هو امتداد لفكرة الإماهة التدريجية
، حيث يتم تحليل القطع الفردية (المكونات / وجهات النظر / الأشجار) التي يتم إعادة
ترطيبها تدريجياً ويتم تحديد تلك التي لديها القليل من التفاعل أو عدم التفاعل. لكل
جزء من هذه الأجزاء الثابتة ، يتم تحويل رمز JavaScript المطابق إلى مراجع خاملة
ووظائف تزيينية ، مما يقلل من بصمة العميل الخاصة به إلى ما يقرب من الصفر. يأتي
نهج الترطيب الجزئي بقضاياه وحلول وسطه. يفرض بعض التحديات المثيرة للتخزين المؤقت
، والتصفح من جانب العميل يعني أننا لا نستطيع أن نفترض أن لغة تأشير النص الفائق
المقدمة من الخادم لأجزاء خاملة من التطبيق ستكون متاحة دون تحميل صفحة كاملة.

### تريسومورفيك ريدينج {: #trisomorphic }

إذا كان [العاملون في
الخدمة](https://developers.google.com/web/fundamentals/primers/service-workers/)
يمثلون خيارًا بالنسبة لك ، فقد يكون العرض "ثلاثي الأشكال" من الأمور المهمة
أيضًا. إنها تقنية يمكنك من خلالها استخدام عرض خادم الدفق للتنقلات الأولية / غير
JS ، ثم يقوم موظف الخدمة لديك بتقديم HTML للتصفح بعد تثبيته. يمكن أن يحافظ هذا
على تحديث المكونات والقوالب المخزنة مؤقتًا ، كما يتيح التنقل على نمط SPA لعرض
طرق عرض جديدة في الجلسة نفسها. يعمل هذا الأسلوب بشكل أفضل عندما يمكنك مشاركة نفس
رمز templating and routing بين الخادم وصفحة العميل وموظف الخدمة.

<img src="../../images/2019/02/rendering-on-the-web/trisomorphic.png"
alt="Diagram of Trisomorphic rendering, showing a browser and service worker
communicating with the server">

## اعتبارات SEO {: #seo }

غالبًا ما تؤثر الفرق في تأثير مُحسّنات محرّكات البحث عند اختيار استراتيجية
للتقديم على الويب. غالبًا ما يتم اختيار تقديم الخادم لتقديم تجربة "كاملة المظهر"
يمكن للزواحف تفسيرها بسهولة. [قد تتفهم
برامج](https://web.dev/discoverable/how-search-works) الزحف [جافا
سكريبت](https://web.dev/discoverable/how-search-works) ، ولكن غالبًا ما تكون
هناك [قيود](/search/docs/guides/rendering) تستحق أن تكون مدركًا لكيفية عرضها.
يمكن أن يعمل العرض من جانب العميل ، ولكن في كثير من الأحيان لا يخلو من اختبارات
إضافية وأعمال الساق. أصبح [العرض
الديناميكي](/search/docs/guides/dynamic-rendering) مؤخرًا خيارًا يستحق النظر فيه
إذا كانت البنية الخاصة بك مدفوعة بشدة بواسطة جافا سكريبت من جانب العميل.

عندما تكون في موضع شك ، فإن أداة
[الاختبار](https://search.google.com/test/mobile-friendly) المألوف للأجهزة
[المحمولة](https://search.google.com/test/mobile-friendly) لا تقدر بثمن لاختبار
أن النهج الذي تختاره يفعل ما تريد. تُظهر لك معاينة مرئية لكيفية ظهور أي صفحة إلى
زاحف Google ومحتوى HTML المتسلسل الموجود (بعد تنفيذ جافا سكريبت) وأي أخطاء تمت
مواجهتها أثناء العرض.

<img src="../../images/2019/02/rendering-on-the-web/mobile-friendly-test.png"
alt="Screenshot of the Mobile Friendly Test UI">

## الختام ... {: #wrapup }

عند اتخاذ قرار بشأن طريقة التقديم ، قم بقياس وفهم ما هي اختناقاتك. فكر فيما إذا
كان التقديم الثابت أو التقديم للخادم يمكن أن يمنحك 90٪ من الطريق إلى هناك. لا
بأس من شحن HTML في الغالب مع الحد الأدنى من JS للحصول على تجربة تفاعلية. فيما
يلي رسم تخطيطي مفيد يوضح طيف الخادم والعميل:

<img src="../../images/2019/02/rendering-on-the-web/infographic.png"
alt="Infographic showing the spectrum of options described in this article">

## ائتمانات {: #credits }

شكرًا للجميع على تعليقاتهم وإلهامهم:

جيفري بوسنيك ، حسين جرده ، شوبي بانيكر ، كريس هارلسون ، وسيباستيان ماركباج

<div class="clearfix"></div>

{% include "web/_shared/helpful.html" %}

{% include "web/_shared/rss-widget-updates.html" %}
