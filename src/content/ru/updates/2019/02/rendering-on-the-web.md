project_path: "/web/_project.yaml"
book_path: "/web/updates/_book.yaml"

{# wf_updated_on: 2019-08-27 #} {# wf_published_on: 2019-02-06 #} {# wf_tags:
fundamentals, performance, app-shell #} {# wf_featured_image:
/web/updates/images/2019/02/rendering-on-the-web/icon.png #} {#
wf_featured_snippet: Where should we implement logic and rendering in our
applications? Should we use Server Side Rendering? What about Rehydration? Let's
find some answers! #} {# wf_blink_components: N/A #}

# Рендеринг в Интернете {: .page-title }

{% include "web/_shared/contributors/developit.html" %} {% include
"web/_shared/contributors/addyosmani.html" %}

Как разработчики, мы часто сталкиваемся с решениями, которые влияют на всю
архитектуру наших приложений. Одно из основных решений, которые должны принять
веб-разработчики, - это где реализовать логику и рендеринг в своих приложениях.
Это может быть сложно, так как существует несколько разных способов создания
сайта.

Наше понимание этого пространства основано на нашей работе в Chrome, в которой
за последние несколько лет мы общались с крупными сайтами. Вообще говоря, мы бы
рекомендовали разработчикам рассмотреть рендеринг сервера или статический
рендеринг с использованием подхода полной регидратации.

Чтобы лучше понять архитектуры, которые мы выбираем, когда принимаем это
решение, нам необходимо иметь четкое понимание каждого подхода и единой
терминологии, которую следует использовать при разговоре о них. Различия между
этими подходами помогают проиллюстрировать компромиссы рендеринга в сети через
призму производительности.

## Терминология {: #terminology }

**Rendering**

- **SSR:** рендеринг на стороне сервера - рендеринг клиентского или
универсального приложения в HTML на сервере.
- **CSR:** рендеринг на стороне клиента - рендеринг приложения в браузере,
обычно с использованием DOM.
- **Регидратация:** «загрузка» представлений JavaScript на клиенте так, чтобы
они повторно использовали дерево DOM и данные HTML, представленные сервером.
- **Предварительный рендеринг:** запуск приложения на стороне клиента во время
сборки для захвата его исходного состояния в виде статического HTML.

**Спектакль**

- **TTFB:** время до первого байта - рассматривается как время между нажатием на
ссылку и первым поступающим контентом.
- **FP:** First Paint - первый раз, когда любой пиксель становится видимым для
пользователя.
- **FCP:** First Contentful Paint - время, когда запрашиваемый контент (тело
статьи и т. Д.) Становится видимым.
- **TTI:** Time To Interactive - время, когда страница становится интерактивной
(события связаны и т. Д.).

## Рендеринг сервера {: #server-rendering }

*Сервер рендеринга генерирует полный HTML для страницы на сервере в ответ на
навигацию. Это позволяет избежать дополнительных циклов обработки данных и
шаблонов на клиенте, поскольку они обрабатываются до того, как браузер получает
ответ.*

Рендеринг сервера обычно производит быструю [First
Paint](https://developers.google.com/web/fundamentals/performance/user-centric-performance-metrics#first_paint_and_first_contentful_paint)
(FP) и [First Contentful
Paint](https://developers.google.com/web/fundamentals/performance/user-centric-performance-metrics#first_paint_and_first_contentful_paint)
(FCP). Выполнение логики страницы и рендеринга на сервере позволяет избежать
отправки большого количества JavaScript клиенту, что помогает ускорить переход
[к интерактивному
времени](https://developers.google.com/web/tools/lighthouse/audits/time-to-interactive)
(TTI). Это имеет смысл, поскольку при рендеринге сервера вы просто отправляете
текст и ссылки в браузер пользователя. Этот подход может хорошо работать для
широкого спектра устройств и условий сети, и открывает интересные оптимизации
браузера, такие как потоковый анализ документов.

<img src="../../images/2019/02/rendering-on-the-web/server-rendering-tti.png"
alt="Diagram showing server rendering and JS execution affecting FCP and TTI"
width="350">

При рендеринге сервера пользователи вряд ли останутся в ожидании обработки
JavaScript с процессором, прежде чем они смогут использовать ваш сайт. Даже
когда нельзя избежать [стороннего
JS](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/loading-third-party-javascript/)
, использование рендеринга сервера для сокращения собственных [затрат на
JS](https://medium.com/@addyosmani/the-cost-of-javascript-in-2018-7d8950fbb5d4)
может дать вам больше «
[бюджета](https://medium.com/@addyosmani/start-performance-budgeting-dabde04cf6a3)
» на все остальное. Однако у этого подхода есть один главный недостаток:
генерация страниц на сервере требует времени, что часто может привести к более
медленному [времени до первого
байта](https://en.wikipedia.org/wiki/Time_to_first_byte) (TTFB).

Достаточно ли рендеринга сервера для вашего приложения, во многом зависит от
типа создаваемого вами опыта. Существует давняя дискуссия о правильном
применении рендеринга сервера по сравнению с рендерингом на стороне клиента, но
важно помнить, что вы можете использовать рендеринг сервера для некоторых
страниц, а не для других. Некоторые сайты успешно применяют гибридные методы
рендеринга. Сервер
[Netflix](https://medium.com/dev-channel/a-netflix-web-performance-case-study-c0bcde26a9d9)
отображает свои относительно статичные целевые страницы, [предварительно
выбирая](https://dev.to/addyosmani/speed-up-next-page-navigations-with-prefetching-4285)
JS для страниц с интенсивным взаимодействием, предоставляя этим более тяжелым
страницам, отображаемым клиентом, более высокую вероятность быстрой загрузки.

Многие современные фреймворки, библиотеки и архитектуры позволяют отображать
одно и то же приложение как на клиенте, так и на сервере. Эти методы могут
использоваться для рендеринга сервера, однако важно отметить, что архитектуры, в
которых рендеринг происходит как на сервере, так ***и*** на клиенте,
представляют собой собственный класс решений с очень разными характеристиками
производительности и компромиссами. Пользователи React могут использовать
[renderToString ()](https://reactjs.org/docs/react-dom-server.html) или решения,
построенные на его основе, такие как [Next.js,](https://nextjs.org) для
рендеринга сервера. Пользователи Vue могут взглянуть на [руководство по
рендерингу серверов](https://ssr.vuejs.org) Vue или [Nuxt](https://nuxtjs.org) .
Угловой имеет [универсальный](https://angular.io/guide/universal) . В
большинстве популярных решений используется некоторая форма гидратации, поэтому
перед выбором инструмента ознакомьтесь с подходом, который используется.

## Статическая визуализация {: #static-rendering }

[Статический
рендеринг](https://frontarm.com/articles/static-vs-server-rendering/) происходит
во время сборки и предлагает быстрые First Paint, First Contentful Paint и Time
To Interactive - при условии, что количество JS на стороне клиента ограничено. В
отличие от рендеринга сервера, ему также удается достичь стабильно быстрого
байта времени до первого, поскольку HTML-код для страницы не нужно генерировать
на лету. Как правило, статический рендеринг означает создание отдельного
HTML-файла для каждого URL-адреса заранее. Поскольку HTML-ответы генерируются
заранее, статические рендеры могут быть развернуты на нескольких CDN, чтобы
воспользоваться преимуществом кэширования краев.

<img src="../../images/2019/02/rendering-on-the-web/static-rendering-tti.png"
alt="Diagram showing static rendering and optional JS execution affecting FCP
and TTI" width="280">

Решения для статического рендеринга бывают разных форм и размеров. Такие
инструменты, как [Gatsby](https://www.gatsbyjs.org) , предназначены для того,
чтобы разработчики чувствовали, что их приложение отображается динамически, а не
генерируется как шаг сборки. Другие, такие как [Jekyl](https://jekyllrb.com) и
[Metalsmith, поддерживают](https://metalsmith.io) свою статичность, предлагая
более шаблонный подход.

Одним из недостатков статического рендеринга является то, что отдельные
HTML-файлы должны создаваться для каждого возможного URL. Это может быть сложно
или даже невозможно, если вы не можете предсказать, какие будут эти URL-адреса
раньше времени, или для сайтов с большим количеством уникальных страниц.

Пользователи React могут быть знакомы с [Gatsby](https://www.gatsbyjs.org) ,
[статическим экспортом
Next.js](https://nextjs.org/learn/excel/static-html-export/) или
[Navi](https://frontarm.com/navi/) - все это делает его удобным для автора с
использованием компонентов. Тем не менее, важно понимать разницу между
статическим рендерингом и предварительным рендерингом: статические рендеринг
страниц являются интерактивными без необходимости выполнения большого количества
JS на стороне клиента, тогда как предварительный рендеринг улучшает первую
краску или первую контентную краску одностраничного приложения, которое
необходимо загрузить клиент для того, чтобы страницы были по-настоящему
интерактивными.

Если вы не уверены, является ли данное решение статическим или предварительным
рендерингом, попробуйте этот тест: отключите JavaScript и загрузите созданные
веб-страницы. Для статически визуализированных страниц большая часть
функциональности будет по-прежнему существовать без включенного JavaScript. Для
предварительно обработанных страниц могут существовать некоторые базовые
функции, такие как ссылки, но большая часть страницы будет инертной.

Еще один полезный тест - замедление работы сети с помощью Chrome DevTools и
наблюдение за загрузкой JavaScript до того, как страница станет интерактивной.
Для предварительного рендеринга обычно требуется больше JavaScript, чтобы стать
интерактивным, и этот JavaScript имеет тенденцию быть более сложным, чем подход
[прогрессивного
улучшения,](https://developer.mozilla.org/en-US/docs/Glossary/Progressive_Enhancement)
используемый при статическом рендеринге.

## Рендеринг сервера против статического рендеринга {: #server-vs-static }

Рендеринг сервера не является серебряной пулей - его динамическая природа может
сопровождаться [значительными вычислительными
накладными](https://medium.com/airbnb-engineering/operationalizing-node-js-for-server-side-rendering-c5ba718acfc9)
расходами. Многие решения для рендеринга серверов не сбрасываются рано, могут
задержать TTFB или удвоить отправку данных (например, встроенное состояние,
используемое JS на клиенте). В React renderToString () может быть медленным,
поскольку он является синхронным и однопоточным. Получение сервера визуализации
«право» может включать в себя нахождение или создание решения для [компонентов
кэширования](https://medium.com/@reactcomponentcaching/speedier-server-side-rendering-in-react-16-with-component-caching-e8aa677929b1)
, управление потреблением памяти, применяя
[запоминанием](https://speakerdeck.com/maxnajim/hastening-react-ssr-with-component-memoization-and-templatization)
методы, и многие другие проблемы. Обычно вы обрабатываете / перестраиваете одно
и то же приложение несколько раз - один раз на клиенте и один раз на сервере.
Тот факт, что при рендеринге с сервера может появиться что-то раньше, не
означает, что у вас меньше работы.

Рендеринг сервера генерирует HTML по требованию для каждого URL, но может быть
медленнее, чем просто обслуживание статического рендеринга контента. Если вы
можете добавить дополнительную работу, рендеринг сервера + [кэширование
HTML](https://freecontent.manning.com/caching-in-react/) может значительно
сократить время рендеринга сервера. Преимуществом рендеринга на сервере является
возможность извлекать больше «живых» данных и отвечать на более полный набор
запросов, чем это возможно при статическом рендеринге. Страницы, требующие
персонализации, являются конкретным примером типа запроса, который не будет
хорошо работать при статическом рендеринге.

Рендеринг сервера также может представлять интересные решения при построении
[PWA](https://developers.google.com/web/progressive-web-apps/) . Лучше
использовать кэширование
[работника](https://developers.google.com/web/fundamentals/primers/service-workers/)
полностраничного
[сервиса](https://developers.google.com/web/fundamentals/primers/service-workers/)
или просто рендерить отдельные части контента на сервере?

## Рендеринг на стороне клиента (CSR) {: #csr }

*Рендеринг на стороне клиента (CSR) означает рендеринг страниц непосредственно в
браузере с использованием JavaScript. Вся логика, выборка данных, шаблоны и
маршрутизация обрабатываются на клиенте, а не на сервере.*

Рендеринг на стороне клиента может быть сложным для получения и хранения для
мобильных устройств. Он может приблизиться к производительности чисто серверного
рендеринга, если выполняет минимальную работу, сохраняя [жесткий бюджет
JavaScript](https://mobile.twitter.com/HenrikJoreteg/status/1039744716210950144)
и предоставляя ценность в
[минимально](https://en.wikipedia.org/wiki/Round-trip_delay_time) возможном
количестве [RTT](https://en.wikipedia.org/wiki/Round-trip_delay_time) .
Критические сценарии и данные могут быть доставлены быстрее, используя [HTTP / 2
Server Push](https://www.smashingmagazine.com/2017/04/guide-http2-server-push/)
или `<link rel=preload>` , что заставляет анализатор работать на вас быстрее.
Шаблоны, такие как
[PRPL](https://developers.google.com/web/fundamentals/performance/prpl-pattern/)
, стоит оценить, чтобы обеспечить мгновенную начальную и последующую навигацию.

<img src="../../images/2019/02/rendering-on-the-web/client-rendering-tti.png"
alt="Diagram showing client-side rendering affecting FCP and TTI" width="500">

Основным недостатком рендеринга на стороне клиента является то, что количество
требуемого JavaScript имеет тенденцию к росту по мере роста приложения. Это
становится особенно трудным с добавлением новых библиотек JavaScript, полифилов
и стороннего кода, которые конкурируют за вычислительную мощность и часто должны
обрабатываться до того, как содержимое страницы может быть отображено. Опыт
работы с CSR, основанный на больших пакетах JavaScript, должен учитывать
[агрессивное разделение
кода](https://developers.google.com/web/fundamentals/performance/optimizing-javascript/code-splitting/)
и обязательно загружать JavaScript - «обслуживайте только то, что вам нужно,
когда вам это нужно». Для случаев, когда интерактивность незначительна или
отсутствует, рендеринг сервера может представлять собой более масштабируемое
решение этих проблем.

Для людей, создающих одностраничное приложение, идентификация основных частей
пользовательского интерфейса, используемых большинством страниц, означает, что
вы можете применить технику [кэширования Application
Shell](https://developers.google.com/web/updates/2015/11/app-shell) . В
сочетании с работниками сферы обслуживания это может значительно улучшить
воспринимаемую производительность при повторных посещениях.

## Объединение рендеринга сервера и CSR через регидратацию {: #rehydration }

Этот подход, часто называемый универсальным рендерингом или просто «SSR»,
пытается сгладить компромиссы между рендерингом на стороне клиента и рендерингом
сервера, выполняя оба действия. Запросы навигации, такие как полная загрузка или
перезагрузка страницы, обрабатываются сервером, который отображает приложение в
HTML, затем JavaScript и данные, используемые для визуализации, встраиваются в
итоговый документ. При аккуратной реализации это обеспечивает быструю First
Contentful Paint точно так же, как серверный рендеринг, а затем «подхватывает»,
снова выполняя рендеринг на клиенте, используя технику, называемую [(ре)
гидратация](https://docs.electrode.io/guides/general/server-side-data-hydration)
. Это новое решение, но оно может иметь некоторые существенные недостатки
производительности.

Основным недостатком SSR с регидратацией является то, что он может оказать
существенное негативное влияние на Time To Interactive, даже если он улучшит
First Paint. Страницы SSR часто выглядят обманчиво загруженными и
интерактивными, но на самом деле не могут реагировать на ввод, пока JS на
стороне клиента не будет выполнен и обработчики событий не присоединены. Это
может занять несколько секунд или даже минут на мобильном телефоне.

Возможно, вы испытали это сами - в течение некоторого времени после того, как
выглядит, как будто страница загружена, нажатие или нажатие ничего не делает.
Это быстро расстраивает ... *«Почему ничего не происходит? Почему я не могу
прокрутить?*

### Проблема регидратации: одно приложение по цене двух {: #rehydration-issues }

Проблемы регидратации часто могут быть хуже, чем замедленная интерактивность
из-за JS. Чтобы клиентский JavaScript мог точно «подхватить», где сервер
остановился, без необходимости повторного запроса всех данных, которые сервер
использовал для визуализации своего HTML, текущие решения по БСО обычно
сериализуют ответ от пользовательского интерфейса. зависимости данных в
документе в виде тегов скрипта. Полученный HTML-документ содержит высокий
уровень дублирования:

<img src="../../images/2019/02/rendering-on-the-web/html.png" alt="HTML document
containing serialized UI, inlined data and a bundle.js script">

Как вы можете видеть, сервер возвращает описание пользовательского интерфейса
приложения в ответ на запрос навигации, но он также возвращает исходные данные,
использованные для создания этого пользовательского интерфейса, и полную копию
реализации пользовательского интерфейса, которая затем загружается на клиенте. ,
Только после завершения загрузки и выполнения bundle.js этот интерфейс
становится интерактивным.

Метрики производительности, собранные с реальных веб-сайтов с использованием
регидратации SSR, указывают на то, что его использование не рекомендуется. В
конечном счете, причина кроется в пользовательском опыте: в конечном итоге
крайне просто оставить пользователей в «странной долине».

<img src="../../images/2019/02/rendering-on-the-web/rehydration-tti.png"
alt="Diagram showing client rendering negatively affecting TTI" width="600">

Хотя есть надежда на ССР с регидратацией. В краткосрочной перспективе только
использование SSR для контента с высокой степенью кэширования может уменьшить
задержку TTFB, что дает результаты, аналогичные предварительному рендерингу.
Регидратация
[постепенно](https://www.emberjs.com/blog/2017/10/10/glimmer-progress-report.html)
, постепенно или частично может стать ключом к повышению эффективности этого
метода в будущем.

## Рендеринг потокового сервера и прогрессивная регидратация {: #progressive-rehydration }

За последние несколько лет рендеринг серверов получил ряд разработок.

[Рендеринг потокового
сервера](https://zeit.co/blog/streaming-server-rendering-at-spectrum) позволяет
отправлять HTML порциями, которые браузер может визуализировать по мере
получения. Это может обеспечить быструю First Paint и First Contentful Paint,
поскольку разметка поступает к пользователям быстрее. В React потоки, являющиеся
асинхронными в [renderToNodeStream
()](https://reactjs.org/docs/react-dom-server.html#rendertonodestream) - по
сравнению с синхронным renderToString - означают, что обратное давление хорошо
обрабатывается.

Прогрессивная регидратация также стоит того, чтобы за ней следить, и кое-что,
что [изучал](https://github.com/facebook/react/pull/14717) React. При таком
подходе отдельные части приложения, отображаемого на сервере, «загружаются» с
течением времени, а не по общему текущему подходу - инициализации всего
приложения сразу. Это может помочь уменьшить объем JavaScript, необходимый для
того, чтобы сделать страницы интерактивными, поскольку обновление на стороне
клиента низкоприоритетных частей страницы может быть отложено для предотвращения
блокировки основного потока. Это также может помочь избежать одной из самых
распространенных ошибок регидратации в SSR, когда дерево DOM, отображаемое
сервером, разрушается, а затем немедленно перестраивается - чаще всего потому,
что при первоначальной синхронной визуализации на стороне клиента требуются не
совсем готовые данные, возможно, ожидающие Promise. разрешающая способность.

### Частичная регидратация {: #partial-rehydration }

Частичная регидратация оказалась трудно осуществимой. Этот подход является
продолжением идеи прогрессивной регидратации, где анализируются отдельные части
(компоненты / виды / деревья), которые должны быть постепенно регидратированы, и
идентифицируются те, у которых мало интерактивности или нет реактивности. Для
каждой из этих в основном статических частей соответствующий код JavaScript
затем преобразуется в инертные ссылки и декоративную функциональность, сокращая
их площадь на стороне клиента почти до нуля. Подход частичной гидратации имеет
свои проблемы и недостатки. Это создает некоторые интересные проблемы для
кэширования, и навигация на стороне клиента означает, что мы не можем
предполагать, что серверный HTML-код для инертных частей приложения будет
доступен без полной загрузки страницы.

### Трисоморфный рендеринг {: #trisomorphic }

Если [сервисные
работники](https://developers.google.com/web/fundamentals/primers/service-workers/)
являются вариантом для вас, «трисоморфный» рендеринг также может представлять
интерес. Это метод, при котором вы можете использовать потоковый рендеринг
сервера для начальной / не-JS-навигации, а затем попросить работника службы
рендеринга HTML-кода для навигации после его установки. Это может поддерживать
кэшированные компоненты и шаблоны в актуальном состоянии и обеспечивает
навигацию в стиле SPA для отображения новых представлений в одном сеансе. Этот
подход работает лучше всего, когда вы можете совместно использовать один и тот
же код шаблонов и маршрутизации между сервером, клиентской страницей и сервисным
работником.

<img src="../../images/2019/02/rendering-on-the-web/trisomorphic.png"
alt="Diagram of Trisomorphic rendering, showing a browser and service worker
communicating with the server">

## SEO соображения {: #seo }

Команды часто учитывают влияние SEO при выборе стратегии рендеринга в сети.
Рендеринг сервера часто выбирается для обеспечения «полного вида», который
сканеры могут легко интерпретировать. Сканеры [могут понимать
JavaScript](https://web.dev/discoverable/how-search-works) , но часто есть
[ограничения, о которых](/search/docs/guides/rendering) стоит знать, как они
рендерится. Рендеринг на стороне клиента может работать, но часто не без
дополнительного тестирования и работы. В последнее время [динамический
рендеринг](/search/docs/guides/dynamic-rendering) также стал вариантом,
заслуживающим внимания, если ваша архитектура сильно зависит от клиентского
JavaScript.

В случае сомнений инструмент [Mobile Friendly
Test](https://search.google.com/test/mobile-friendly) неоценим для проверки
того, что выбранный вами подход делает то, на что вы надеетесь. Он показывает
визуальный предварительный просмотр того, как какая-либо страница отображается
сканеру Google, найденный сериализованный контент HTML (после выполнения
JavaScript) и любые ошибки, обнаруженные во время рендеринга.

<img src="../../images/2019/02/rendering-on-the-web/mobile-friendly-test.png"
alt="Screenshot of the Mobile Friendly Test UI">

## Завершение ... {: #wrapup }

При выборе подхода к визуализации измерьте и поймите, какие у вас узкие места.
Подумайте, может ли статический рендеринг или рендеринг сервера получить вам 90%
пути. Совершенно нормально в основном отправлять HTML с минимальным JS, чтобы
получить интерактивный опыт. Вот удобная инфографика, показывающая спектр
сервер-клиент:

<img src="../../images/2019/02/rendering-on-the-web/infographic.png"
alt="Infographic showing the spectrum of options described in this article">

## Кредиты {: #credits }

Спасибо всем за их отзывы и вдохновение:

Джеффри Посник, Хуссейн Джирде, Шубхи Паникер, Крис Харрельсон и Себастьян
Маркбаге

<div class="clearfix"></div>

{% include "web/_shared/helpful.html" %}

{% include "web/_shared/rss-widget-updates.html" %}
